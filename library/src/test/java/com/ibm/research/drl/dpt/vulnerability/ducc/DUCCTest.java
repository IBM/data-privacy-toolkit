/*******************************************************************
 *                                                                 *
 * Copyright IBM Corp. 2015                                        *
 *                                                                 *
 *******************************************************************/
package com.ibm.research.drl.dpt.vulnerability.ducc;

import com.ibm.research.drl.dpt.datasets.IPVDataset;
import com.ibm.research.drl.dpt.vulnerability.IPVVulnerability;
import com.ibm.research.drl.dpt.vulnerability.brute.Brute;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.not;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;


public class DUCCTest {

    @Disabled
    @Test
    public void testONSmallScaleFromMOH() {
        List<List<String>> syntheticDataset = new ArrayList<>();
        syntheticDataset.add( Arrays.asList("70", "7", "0", "0171", "1", "3", "3", "66", "1") );
        syntheticDataset.add( Arrays.asList("70", "7", "0", "0171", "2", "3", "3", "74", "1") );
        syntheticDataset.add( Arrays.asList("70", "7", "0", "0171", "2", "3", "3", "66", "1") );


        IPVDataset dataset = new IPVDataset(syntheticDataset, null, false);

        DUCC algorightm = new DUCC(1, DUCC.Strategy.RECURSIVE, 3);

        Collection<IPVVulnerability> vulnerabilities = algorightm.apply(dataset);

        System.out.println(vulnerabilities);
    }

    @Disabled
    @Test
    public void testOnDataLargerRecursive() throws Exception {
        IPVDataset dataset = IPVDataset.load(getClass().getResourceAsStream("/adult-15-45000.data"), false, ',', '"', false);

        DUCC algorithm = new DUCC(1, DUCC.Strategy.RECURSIVE, 2);
        Collection<IPVVulnerability> vulnerabilities = algorithm.apply(dataset);

        for (IPVVulnerability vulnerability : vulnerabilities) {
            System.out.println(vulnerability);
        }
    }

    @Disabled
    @Test
    public void testOnDataLarger() throws Exception {
        IPVDataset dataset = IPVDataset.load(getClass().getResourceAsStream("/adult-15-45000.data"), false, ',', '"', false);

        DUCC algorithm = new DUCC(1, DUCC.Strategy.DESCENDING, 2);
        Collection<IPVVulnerability> vulnerabilities = algorithm.apply(dataset);

        for (IPVVulnerability vulnerability : vulnerabilities) {
            System.out.println(vulnerability);
        }
    }

    @Test
    public void testCorrectnessSimple() throws Exception {
        IPVDataset dataset = IPVDataset.load(getClass().getResourceAsStream("/adult-columns-5-7.csv"), false, ',', '"', false);

        int k = 2;

        Brute brute = new Brute(k);
        Collection<IPVVulnerability> bruteVulnerabilities = brute.apply(dataset);

        DUCC algorithm = new DUCC(1, DUCC.Strategy.DESCENDING, k);
        Collection<IPVVulnerability> vulnerabilities = algorithm.apply(dataset);

        assertEquals(bruteVulnerabilities.size(), vulnerabilities.size());

        for (IPVVulnerability vulnerability : vulnerabilities) {
            assertTrue(bruteVulnerabilities.contains(vulnerability));
        }
    }

    @Test
    public void testCorrectness() throws Exception {
        IPVDataset dataset = IPVDataset.load(getClass().getResourceAsStream("/adult-10-30000.data.csv"), false, ',', '"', false);

        int k = 2;

        Brute brute = new Brute(k);
        Collection<IPVVulnerability> bruteVulnerabilities = brute.apply(dataset);

        DUCC algorithm = new DUCC(1, DUCC.Strategy.DESCENDING, k);
        Collection<IPVVulnerability> vulnerabilities = algorithm.apply(dataset);

        assertEquals(vulnerabilities.size(), bruteVulnerabilities.size());

        for (IPVVulnerability vulnerability : vulnerabilities) {
            assertTrue(bruteVulnerabilities.contains(vulnerability));
        }
    }

    @Test
    public void testOnDataDescending() throws Exception {
        final List<String> expectedResults = new ArrayList<>(Arrays.asList(
                "[0]",
                "[3]",
                "[1,4]",
                "[2,4]"
        ));
        IPVDataset dataset = IPVDataset.load(getClass().getResourceAsStream("/100.csv"), false, ',', '"', false);

        DUCC algorithm = new DUCC(1, DUCC.Strategy.DESCENDING, 3);
        Collection<IPVVulnerability> vulnerabilities = algorithm.apply(dataset);

        assertThat(vulnerabilities.size(), is(expectedResults.size()));

        for (IPVVulnerability vulnerability : vulnerabilities) {
            String vul = vulnerability.toString();
            assertTrue(expectedResults.contains(vul));

            int index = expectedResults.indexOf(vul);
            assertThat(index, not(-1));
            assertThat(expectedResults.remove(index), is(vul));
        }

        assertTrue(expectedResults.isEmpty());
    }

    @Test
    public void testOnDataRecursive() throws Exception {
        final List<String> expectedResults = new ArrayList<>(Arrays.asList(
                "[0]",
                "[3]",
                "[1,4]",
                "[2,4]"
        ));
        IPVDataset dataset = IPVDataset.load(getClass().getResourceAsStream("/100.csv"), false, ',', '"', false);

        DUCC algorithm = new DUCC(1, DUCC.Strategy.RECURSIVE, 3);
        Collection<IPVVulnerability> vulnerabilities = algorithm.apply(dataset);

        assertThat(vulnerabilities.size(), is(expectedResults.size()));

        for (IPVVulnerability vulnerability : vulnerabilities) {
            String vul = vulnerability.toString();
            assertTrue(expectedResults.contains(vul));

            int index = expectedResults.indexOf(vul);
            assertThat(index, not(-1));
            assertThat(expectedResults.remove(index), is(vul));
        }

        assertTrue(expectedResults.isEmpty());
    }

    @Test
    public void testOnDataRecursiveWithSync() throws Exception {
        final List<String> expectedResults = new ArrayList<>(Arrays.asList(
                "[0]",
                "[3]",
                "[1,4]",
                "[2,4]"
        ));
        IPVDataset dataset = IPVDataset.load(getClass().getResourceAsStream("/100.csv"), false, ',', '"', false);

        DUCC algorithm = new DUCC(1, DUCC.Strategy.RECURSIVE, 3);
        Collection<IPVVulnerability> vulnerabilities = algorithm.apply(dataset);

        assertThat(vulnerabilities.size(), is(expectedResults.size()));

        for (IPVVulnerability vulnerability : vulnerabilities) {
            String vul = vulnerability.toString();
            assertTrue(expectedResults.contains(vul));

            int index = expectedResults.indexOf(vul);
            assertThat(index, not(-1));
            assertThat(expectedResults.remove(index), is(vul));
        }

        assertTrue(expectedResults.isEmpty());
    }
}
