/*******************************************************************
 *                                                                 *
 * Copyright IBM Corp. 2015                                        *
 *                                                                 *
 *******************************************************************/
package com.ibm.research.drl.dpt.vulnerability.ducc;

import com.ibm.research.drl.dpt.generators.ItemSet;

public class DUCCWorkerRecursiveWithSync extends DUCCWorkerRecursive {
    private final LocalPrunedGraphs localGraphs;

    /**
     * Instantiates a new Ducc worker recursive with sync.
     *
     * @param seeds         the seeds
     * @param pliRepository the pli repository
     * @param graphs        the graphs
     * @param kValue        the k value
     */
    public DUCCWorkerRecursiveWithSync(DUCCPriorityBlockingQueue seeds, PLIRepository pliRepository, PrunedGraphs graphs, int kValue) {
        super(seeds, pliRepository, graphs, kValue);
        localGraphs = new LocalPrunedGraphs();
    }

    @Override
    public Double call() throws Exception {
        while (!seeds.isEmpty()) {
            ItemSet K = seeds.poll();
            if (null == K) continue;

            // sync graph
            process(K, localGraphs);

            localGraphs.sync(graphs);
        }

        // sync graph

        return null;
    }

    private void process(ItemSet K, LocalPrunedGraphs graphs) {
        if (graphs.isNodePruned(K) || hasUnique(pliRepository.getAll(K))) {
            // mark all superset as unique
            graphs.addUnique(K);
            seeds.removeSuperSets(K);

            if (K.size() > 2) {
                for (Integer item : K.getItems()) {
                    ItemSet kPrime = new ItemSet(K);
                    kPrime.removeItem(item);

                    if (!graphs.isNodePruned(kPrime)) {
                        process(kPrime, graphs);
                    }
                }
            }
        } else {
            // K is not unique
            graphs.addNotUnique(K);
            seeds.removeSubSets(K);
            // iterate over all superset
            for (Integer attribute : validAttributes) {
                if (K.canBeExtendWith(attribute)) {
                    ItemSet kPrime = new ItemSet(K, attribute);
                    if (!graphs.isNodePruned(kPrime)) {
                        process(kPrime, graphs);
                    }
                }
            }
        }
    }
}

