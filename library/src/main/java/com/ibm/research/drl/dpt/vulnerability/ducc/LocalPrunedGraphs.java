/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/
package com.ibm.research.drl.dpt.vulnerability.ducc;

import com.ibm.research.drl.dpt.generators.ItemSet;

import java.util.LinkedList;
import java.util.List;

public class LocalPrunedGraphs {
    private final List<ItemSet> uniques;
    private final List<ItemSet> notUniques;

    /**
     * Instantiates a new Local pruned graphs.
     */
    public LocalPrunedGraphs() {
        uniques = new LinkedList<>();
        notUniques = new LinkedList<>();
    }

    /**
     * Sync.
     *
     * @param graphs the graphs
     */
    public void sync(PrunedGraphs graphs) {
        // sync uniques
        graphs.addUnique(uniques);

        for (ItemSet is : graphs.getUniques()) {
            addUnique(is);
        }

        // sync notUniques
        graphs.addNotUnique(notUniques);

        for (ItemSet is : graphs.getNotUniques()) {
            addNotUnique(is);
        }
    }

    /**
     * Is node pruned boolean.
     *
     * @param itemSet the item set
     * @return the boolean
     */
    public boolean isNodePruned(ItemSet itemSet) {
        return
                // check positive
                isKnownToBeUnsafe(itemSet) ||
                        // check negative
                        isKnownToBeSafe(itemSet);
    }

    /**
     * Is known to be unsafe boolean.
     *
     * @param itemSet the item set
     * @return the boolean
     */
    private boolean isKnownToBeUnsafe(ItemSet itemSet) {
        for (ItemSet o : uniques) {
            if (o.isSubSetOf(itemSet)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Is known to be safe boolean.
     *
     * @param itemSet the item set
     * @return the boolean
     */
    private boolean isKnownToBeSafe(ItemSet itemSet) {
        for (ItemSet o : notUniques) {
            if (itemSet.isSubSetOf(o)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Add unique.
     *
     * @param itemSet the item set
     */
    public void addUnique(ItemSet itemSet) {
        for (int i = 0; i < uniques.size(); ) {
            ItemSet o = uniques.get(i);

            if (itemSet.isSubSetOf(o)) {
                uniques.remove(i);
            } else if (o.isSubSetOf(itemSet)) {
                return;
            } else {
                ++i;
            }
        }

        uniques.add(itemSet);
    }

    /**
     * Add not unique.
     *
     * @param itemSet the item set
     */
    public void addNotUnique(ItemSet itemSet) {
        for (int i = 0; i < notUniques.size(); ) {
            ItemSet o = notUniques.get(i);

            if (o.isSubSetOf(itemSet)) {
                notUniques.remove(i);
            } else if (itemSet.isSubSetOf(o)) {
                return;
            } else {
                ++i;
            }
        }

        notUniques.add(itemSet);
    }
}
