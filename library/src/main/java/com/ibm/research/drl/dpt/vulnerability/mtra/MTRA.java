/*******************************************************************
 *                                                                 *
 * Copyright IBM Corp. 2022                                        *
 *                                                                 *
 *******************************************************************/
package com.ibm.research.drl.dpt.vulnerability.mtra;

import com.ibm.research.drl.dpt.IPVAlgorithm;
import com.ibm.research.drl.dpt.datasets.IPVDataset;
import com.ibm.research.drl.dpt.generators.IPVGenerator;
import com.ibm.research.drl.dpt.generators.LayerGenerator;
import com.ibm.research.drl.dpt.vulnerability.IPVVulnerability;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;;

import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;


public class MTRA implements IPVAlgorithm {
    private static final Logger logger = LogManager.getLogger(MTRA.class);
    private static final double DEFAULT_MULTIPLIER = 1.5d;

    private final int nThread;
    private final double multiplier;

    /**
     * Instantiates a new Mtra.
     *
     * @param nThread    the n thread
     * @param multiplier the multiplier
     */
    public MTRA(int nThread, final double multiplier) {
        this.nThread = nThread;
        this.multiplier = multiplier;
    }

    public MTRA(int nThread) {
        this(nThread, DEFAULT_MULTIPLIER);
    }

    private class MutableInteger {
        private int val;
        public MutableInteger(int val) {
            this.val = val;
        }

        public int get() {
            return val;
        }

        public void set(int val) {
            this.val = val;
        }

        @Override
        public String toString() {
            return Integer.toString(val);
        }
    }

    @Override
    public Collection<IPVVulnerability> apply(final IPVDataset dataset) {
        final IPVGenerator generator = new LayerGenerator(dataset.getNumberOfColumns());

        final ConcurrentLinkedQueue<MTRATask> tasks = new ConcurrentLinkedQueue<>();
        final ConcurrentLinkedQueue<MTRAResult> results = new ConcurrentLinkedQueue<>();

        for (int i = 0; generator.hasNext() && i < (nThread * multiplier); ++i) {
            tasks.add(new MTRATask(generator.next()));
        }

        // init executors
        final Thread[] executors = new Thread[nThread];
        int counter = 0;
        for (int i = 0; i < nThread; ++i) {
            executors[i] = new Thread(() -> {
                while (true) {
                    MTRATask task = tasks.poll();
                    MTRAResult result;

                    if (null == task) {
                        continue;
                    }

                    if (null == task.getItemSet()) {
                        results.add(new MTRAResult(null, -1));
                        return; // termination condition
                    }

                    final Map<String, MutableInteger> counters = new HashMap<>();

                    // process data
                    for (int row = 0; row < dataset.getNumberOfRows(); ++row) {
                        StringBuilder builder = new StringBuilder();
                        for (Integer column: task.getItemSet().getItems()) {
                            builder.append(',');
                            builder.append(dataset.get(row, column));
                        }
                        final String key = builder.toString();

                        MutableInteger counterValue = counters.get(key);

                        if (null != counterValue) {
                            counterValue.set(counterValue.get() + 1);
                        } else {
                            counters.put(key, new MutableInteger(1));
                        }
                    }

                    int k = Integer.MAX_VALUE;

                    for (Map.Entry<String, MutableInteger> counter1 : counters.entrySet()) {
                        k = Math.min(k, counter1.getValue().get());
                    }

                    result = new MTRAResult(task, k);

                    results.add(result);
                }
            });
            counter += 1;
            executors[i].start();
        }

        boolean terminated = false;

        final List<IPVVulnerability> vulnerabilities = new LinkedList<>();

        while (0 < counter) {
            MTRAResult result = results.poll();

            if (null == result) {
                continue;
            }

            if (null == result.getTask()) {
                counter -= 1;
                continue;
            }

            vulnerabilities.add(new IPVVulnerability(result.getTask().getItemSet(), result.getkValue()));

            if (generator.hasNext()) {
                final MTRATask task = new MTRATask(generator.next());

                tasks.add(task);
            } else if (! terminated) {
                for (int i = 0; i < nThread; ++i) {
                    tasks.add(new MTRATask(null));
                }
                terminated = true;
            }
        }


        return vulnerabilities;
    }
}
