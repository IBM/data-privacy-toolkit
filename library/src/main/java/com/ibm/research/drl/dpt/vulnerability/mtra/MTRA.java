/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/
package com.ibm.research.drl.dpt.vulnerability.mtra;

import com.ibm.research.drl.dpt.IPVAlgorithm;
import com.ibm.research.drl.dpt.datasets.IPVDataset;
import com.ibm.research.drl.dpt.generators.IPVGenerator;
import com.ibm.research.drl.dpt.generators.LayerGenerator;
import com.ibm.research.drl.dpt.vulnerability.IPVVulnerability;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;


public class MTRA implements IPVAlgorithm {
    private static final Logger logger = LogManager.getLogger(MTRA.class);
    private static final double DEFAULT_MULTIPLIER = 1.5d;

    private final int nThread;
    private final double multiplier;

    /**
     * Instantiates a new Mtra.
     *
     * @param nThread    the n thread
     * @param multiplier the multiplier
     */
    public MTRA(int nThread, final double multiplier) {
        this.nThread = nThread;
        this.multiplier = multiplier;
    }

    public MTRA(int nThread) {
        this(nThread, DEFAULT_MULTIPLIER);
    }

    private static class MutableInteger {
        private int val;

        public MutableInteger(int val) {
            this.val = val;
        }

        public int get() {
            return val;
        }

        public void set(int val) {
            this.val = val;
        }

        @Override
        public String toString() {
            return Integer.toString(val);
        }
    }

    @Override
    public Collection<IPVVulnerability> apply(final IPVDataset dataset) {
        final IPVGenerator generator = new LayerGenerator(dataset.getNumberOfColumns());

        final ConcurrentLinkedQueue<MTRATask> tasks = new ConcurrentLinkedQueue<>();
        final ConcurrentLinkedQueue<MTRAResult> results = new ConcurrentLinkedQueue<>();

        int parallelism = (int) (nThread * multiplier);
        for (int i = 0; generator.hasNext() && i < parallelism; ++i) {
            tasks.add(new MTRATask(generator.next()));
        }

        // init executors
        final Thread[] executors = new Thread[nThread];
        int counter = 0;
        for (int i = 0; i < nThread; ++i) {
            executors[i] = new Thread(() -> {
                while (true) {
                    MTRATask task = tasks.poll();
                    MTRAResult result;

                    if (null == task) {
                        continue;
                    }

                    if (null == task.getItemSet()) {
                        results.add(new MTRAResult(null, -1));
                        return; // termination condition
                    }

                    final Map<String, MutableInteger> counters = new HashMap<>();

                    // process data
                    for (int row = 0; row < dataset.getNumberOfRows(); ++row) {
                        StringBuilder builder = new StringBuilder();
                        for (Integer column : task.getItemSet().getItems()) {
                            builder.append(',');
                            builder.append(dataset.get(row, column));
                        }
                        final String key = builder.toString();

                        MutableInteger counterValue = counters.get(key);

                        if (null != counterValue) {
                            counterValue.set(counterValue.get() + 1);
                        } else {
                            counters.put(key, new MutableInteger(1));
                        }
                    }

                    int k = Integer.MAX_VALUE;

                    for (Map.Entry<String, MutableInteger> counter1 : counters.entrySet()) {
                        k = Math.min(k, counter1.getValue().get());
                    }

                    result = new MTRAResult(task, k);

                    results.add(result);
                }
            });
            counter += 1;
            executors[i].start();
        }

        boolean terminated = false;

        final List<IPVVulnerability> vulnerabilities = new LinkedList<>();

        while (0 < counter) {
            MTRAResult result = results.poll();

            if (null == result) {
                continue;
            }

            if (null == result.getTask()) {
                counter -= 1;
                continue;
            }

            vulnerabilities.add(new IPVVulnerability(result.getTask().getItemSet(), result.getkValue()));

            if (generator.hasNext()) {
                final MTRATask task = new MTRATask(generator.next());

                tasks.add(task);
            } else if (!terminated) {
                for (int i = 0; i < nThread; ++i) {
                    tasks.add(new MTRATask(null));
                }
                terminated = true;
            }
        }


        return vulnerabilities;
    }
}
