/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/
package com.ibm.research.drl.dpt.vulnerability.ducc;

import com.ibm.research.drl.dpt.generators.ItemSet;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.locks.ReentrantLock;

public class PrunedGraphs {
    private final List<ItemSet> uniques;
    private final List<ItemSet> notUniques;
    private final ReentrantLock lock;

    /**
     * Instantiates a new Pruned graphs.
     */
    public PrunedGraphs() {
        notUniques = new LinkedList<>();
        uniques = new LinkedList<>();
        lock = new ReentrantLock();
    }

    /**
     * Is node pruned boolean.
     *
     * @param itemSet the item set
     * @return the boolean
     */
    public boolean isNodePruned(ItemSet itemSet) {
        return
                // check positive
                isKnownToBeUnsafe(itemSet) ||
                        // check negative
                        isKnownToBeSafe(itemSet);

    }

    /**
     * Is known to be unsafe boolean.
     *
     * @param itemSet the item set
     * @return the boolean
     */
    private boolean isKnownToBeUnsafe(ItemSet itemSet) {
        final ReentrantLock lock = this.lock;
        try {
            lock.lock();

            for (ItemSet o : uniques) {
                if (o.isSubSetOf(itemSet)) {
                    //logger.debug("{} is subset of {}", o, itemSet);
                    return true;
                }
            }

            return false;
        } finally {
            lock.unlock();
        }
    }

    /**
     * Is known to be safe boolean.
     *
     * @param itemSet the item set
     * @return the boolean
     */
    private boolean isKnownToBeSafe(ItemSet itemSet) {
        final ReentrantLock lock = this.lock;
        try {
            lock.lock();

            for (ItemSet o : notUniques) {
                if (itemSet.isSubSetOf(o)) {
                    return true;
                }
            }

            return false;
        } finally {
            lock.unlock();
        }
    }

    /**
     * Add unique.
     *
     * @param uniques the uniques
     */
    public void addUnique(List<ItemSet> uniques) {
        final ReentrantLock lock = this.lock;

        try {
            lock.lock();

            for (ItemSet is : uniques) {
                addUnique(is);
            }
        } finally {
            lock.unlock();
        }
    }

    /**
     * Add unique.
     *
     * @param itemSet the item set
     */
    public void addUnique(ItemSet itemSet) {
        final ReentrantLock lock = this.lock;
        try {
            lock.lock();

            for (int i = 0; i < uniques.size(); ) {
                ItemSet o = uniques.get(i);


                if (itemSet.isSubSetOf(o)) {
                    uniques.remove(i);
                } else if (o.isSubSetOf(itemSet)) {
                    return;
                } else {
                    ++i;
                }
            }

            uniques.add(itemSet);
        } finally {
            lock.unlock();
        }
    }

    /**
     * Gets uniques.
     *
     * @return the uniques
     */
    public List<ItemSet> getUniques() {
        final ReentrantLock lock = this.lock;
        try {
            lock.lock();

            return new ArrayList<>(uniques);
        } finally {
            lock.unlock();
        }
    }

    /**
     * Gets not uniques.
     *
     * @return the not uniques
     */
    public List<ItemSet> getNotUniques() {
        final ReentrantLock lock = this.lock;
        try {
            lock.lock();

            return new ArrayList<>(notUniques);
        } finally {
            lock.unlock();
        }
    }

    /**
     * Add not unique.
     *
     * @param notUniques the not uniques
     */
    public void addNotUnique(List<ItemSet> notUniques) {
        final ReentrantLock lock = this.lock;

        try {
            lock.lock();

            for (ItemSet is : notUniques) {
                addNotUnique(is);
            }
        } finally {
            lock.unlock();
        }
    }

    /**
     * Add not unique.
     *
     * @param itemSet the item set
     */
    public void addNotUnique(ItemSet itemSet) {
        final ReentrantLock lock = this.lock;
        try {
            lock.lock();

            for (int i = 0; i < notUniques.size(); ) {
                ItemSet o = notUniques.get(i);

                if (o.isSubSetOf(itemSet)) {
                    notUniques.remove(i);
                } else if (itemSet.isSubSetOf(o)) {
                    return;
                } else {
                    ++i;
                }
            }

            notUniques.add(itemSet);
        } finally {
            lock.unlock();
        }
    }
}
