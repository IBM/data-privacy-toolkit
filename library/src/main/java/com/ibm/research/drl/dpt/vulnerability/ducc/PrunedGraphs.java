/*******************************************************************
 *                                                                 *
 * Copyright IBM Corp. 2015                                        *
 *                                                                 *
 *******************************************************************/
package com.ibm.research.drl.dpt.vulnerability.ducc;

import com.ibm.research.drl.dpt.generators.ItemSet;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.locks.ReentrantLock;

public class PrunedGraphs {
    private final List<ItemSet> uniques;
    private final List<ItemSet> notUniques;
    private final ReentrantLock lock;

    /**
     * Instantiates a new Pruned graphs.
     */
    public PrunedGraphs() {
        notUniques = new LinkedList<>();
        uniques = new LinkedList<>();
        lock = new ReentrantLock();
    }

    /**
     * Is node pruned boolean.
     *
     * @param itemSet the item set
     * @return the boolean
     */
    public boolean isNodePruned(ItemSet itemSet) {
        return
                // check positive
                isKnownToBeUnsafe(itemSet) ||
                        // check negative
                        isKnownToBeSafe(itemSet);

    }

    /**
     * Is known to be unsafe boolean.
     *
     * @param itemSet the item set
     * @return the boolean
     */
    private boolean isKnownToBeUnsafe(ItemSet itemSet) {
        final ReentrantLock lock = this.lock;
        try {
            lock.lock();

            for (ItemSet o : uniques) {
                if (o.isSubSetOf(itemSet)) {
                    //logger.debug("{} is subset of {}", o, itemSet);
                    return true;
                }
            }

            return false;
        } finally {
            lock.unlock();
        }
    }

    /**
     * Is known to be safe boolean.
     *
     * @param itemSet the item set
     * @return the boolean
     */
    private boolean isKnownToBeSafe(ItemSet itemSet) {
        final ReentrantLock lock = this.lock;
        try {
            lock.lock();

            for (ItemSet o : notUniques) {
                if (itemSet.isSubSetOf(o)) {
                    return true;
                }
            }

            return false;
        } finally {
            lock.unlock();
        }
    }

    /**
     * Add unique.
     *
     * @param uniques the uniques
     */
    public void addUnique(List<ItemSet> uniques) {
        final ReentrantLock lock = this.lock;

        try {
            lock.lock();

            for (ItemSet is : uniques) {
                addUnique(is);
            }
        } finally {
            lock.unlock();
        }
    }

    /**
     * Add unique.
     *
     * @param itemSet the item set
     */
    public void addUnique(ItemSet itemSet) {
        final ReentrantLock lock = this.lock;
        try {
            lock.lock();

            for (int i = 0; i < uniques.size(); ) {
                ItemSet o = uniques.get(i);


                if (itemSet.isSubSetOf(o)) {
                    uniques.remove(i);
                } else if (o.isSubSetOf(itemSet)) {
                    return;
                } else {
                    ++i;
                }
            }

            uniques.add(itemSet);
        } finally {
            lock.unlock();
        }
    }

    /**
     * Gets uniques.
     *
     * @return the uniques
     */
    public List<ItemSet> getUniques() {
        final ReentrantLock lock = this.lock;
        try {
            lock.lock();

            return new ArrayList<>(uniques);
        } finally {
            lock.unlock();
        }
    }

    /**
     * Gets not uniques.
     *
     * @return the not uniques
     */
    public List<ItemSet> getNotUniques() {
        final ReentrantLock lock = this.lock;
        try {
            lock.lock();

            return new ArrayList<>(notUniques);
        } finally {
            lock.unlock();
        }
    }

    /**
     * Add not unique.
     *
     * @param notUniques the not uniques
     */
    public void addNotUnique(List<ItemSet> notUniques) {
        final ReentrantLock lock = this.lock;

        try {
            lock.lock();

            for (ItemSet is : notUniques) {
                addNotUnique(is);
            }
        } finally {
            lock.unlock();
        }
    }

    /**
     * Add not unique.
     *
     * @param itemSet the item set
     */
    public void addNotUnique(ItemSet itemSet) {
        final ReentrantLock lock = this.lock;
        try {
            lock.lock();

            for (int i = 0; i < notUniques.size(); ) {
                ItemSet o = notUniques.get(i);

                if (o.isSubSetOf(itemSet)) {
                    notUniques.remove(i);
                } else if (itemSet.isSubSetOf(o)) {
                    return;
                } else {
                    ++i;
                }
            }

            notUniques.add(itemSet);
        } finally {
            lock.unlock();
        }
    }
}
