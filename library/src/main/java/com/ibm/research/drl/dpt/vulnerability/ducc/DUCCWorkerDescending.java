/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/
package com.ibm.research.drl.dpt.vulnerability.ducc;

import com.ibm.research.drl.dpt.generators.ItemSet;

import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

public class DUCCWorkerDescending implements DUCCWorker {
    /**
     * The Seeds.
     */
    protected final DUCCPriorityBlockingQueue seeds;
    /**
     * The Pli repository.
     */
    protected final PLIRepository pliRepository;
    /**
     * The Valid attributes.
     */
    protected final List<Integer> validAttributes;
    /**
     * The K value.
     */
    protected final int kValue;
    /**
     * The Graphs.
     */
    protected PrunedGraphs graphs;

    /**
     * Instantiates a new Ducc worker descending.
     *
     * @param seeds         the seeds
     * @param pliRepository the pli repository
     * @param graphs        the graphs
     * @param kValue        the k value
     */
    public DUCCWorkerDescending(DUCCPriorityBlockingQueue seeds, PLIRepository pliRepository, PrunedGraphs graphs, int kValue) {
        this.seeds = seeds;
        this.pliRepository = pliRepository;

        this.graphs = graphs;
        this.kValue = kValue;
        this.validAttributes = pliRepository.getAttributeNames();
    }

    @Override
    public Double call() throws Exception {
        double itemsetsChecked = 0;

        while (!seeds.isEmpty() || seeds.isThereAnActiveWorker()) {
            ItemSet K = seeds.poll();
            try {
                if (null == K) continue;
                seeds.isActive(this);

                if (graphs.isNodePruned(K)) continue;

                itemsetsChecked++;

                final List<Collection<RowIDSet>> kPLIs = pliRepository.getAll(K);

                if (hasUnique(kPLIs)) {
                    // mark all superset as unique
                    graphs.addUnique(K);
                    seeds.removeSuperSets(K);
                } else {
                    // K is not unique
                    graphs.addNotUnique(K);
                    seeds.removeSubSets(K);
                    // iterate over all superset
                    for (Integer attribute : pliRepository.getAttributeNames()) {
                        if (K.canBeExtendWith(attribute)) {
                            // dumb version, need to verify that attribute can go to K
                            ItemSet kPrime = new ItemSet(K, attribute);
                            if (!graphs.isNodePruned(kPrime)) {
                                seeds.add(kPrime);
                            }
                        }
                    }
                }
            } finally {
                seeds.done(this);
            }
        }

        return itemsetsChecked;
    }

    static Iterator<RowIDSet> getCombinations(final List<Collection<RowIDSet>> lists) {
        switch (lists.size()) {
            case 0:
                throw new IllegalArgumentException("List has to contain at least a set");
            case 1:
                return lists.get(0).iterator();
            default:
                final Iterator<RowIDSet> current = lists.get(0).iterator();

                return new Iterator<RowIDSet>() {
                    RowIDSet element;
                    Iterator<RowIDSet> other;

                    @Override
                    public boolean hasNext() {
                        return current.hasNext() || (null != other && other.hasNext());
                    }

                    @Override
                    public RowIDSet next() {
                        if (!hasNext()) throw new NoSuchElementException();

                        if (null == other || !other.hasNext()) {
                            element = current.next();
                            other = getCombinations(lists.subList(1, lists.size()));
                        }

                        return element.intersect(other.next());
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
        }
    }


    /**
     * Has unique boolean.
     *
     * @param uniqueValues the unique values
     * @return the boolean
     */
    protected boolean hasUnique(List<Collection<RowIDSet>> uniqueValues) {
        Iterator<RowIDSet> uniqueValueIterator = getCombinations(uniqueValues);

        while (uniqueValueIterator.hasNext()) {
            RowIDSet combination = uniqueValueIterator.next();

            if (combination.isEmpty()) {
                continue;
            }

            if (kValue > combination.size()) {
                return true;
            }
        }

        return false;
    }
}
