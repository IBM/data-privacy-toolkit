/*******************************************************************
 *                                                                 *
 * Copyright IBM Corp. 2020                                        *
 *                                                                 *
 *******************************************************************/
package com.ibm.research.drl.dpt.vulnerability.brute;


import com.ibm.research.drl.dpt.IPVAlgorithm;
import com.ibm.research.drl.dpt.anonymization.VerificationUtils;
import com.ibm.research.drl.dpt.datasets.IPVDataset;
import com.ibm.research.drl.dpt.generators.IPVGenerator;
import com.ibm.research.drl.dpt.generators.ItemSet;
import com.ibm.research.drl.dpt.generators.LayerGenerator;
import com.ibm.research.drl.dpt.vulnerability.IPVVulnerability;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;;

import java.util.ArrayList;
import java.util.Collection;
import java.util.concurrent.ConcurrentLinkedQueue;

public class ParallelBrute implements IPVAlgorithm {
    private static final Logger logger = LogManager.getLogger(ParallelBrute.class);

    private static class BruteResult {
        private final ItemSet itemSet;
        private final boolean isUnique;

        private BruteResult(ItemSet itemSet, boolean isUnique) {
            this.itemSet = itemSet;
            this.isUnique = isUnique;
        }

        public ItemSet getItemSet() {
            return itemSet;
        }

        public boolean isUnique() {
            return isUnique;
        }
    }

    private static class BruteRequest {
        private final ItemSet itemSet;

        private BruteRequest(ItemSet itemSet) {
            this.itemSet = itemSet;
        }

        public ItemSet getItemSet() {
            return itemSet;
        }
    }

    private final int k;
    private final int nThread;

    public ParallelBrute(int kValue, int nThread) {
        this.k = kValue;
        this.nThread = nThread;
    }

    @Override
    public Collection<IPVVulnerability> apply(final IPVDataset dataset) {
        final IPVGenerator generator = new LayerGenerator(dataset.getNumberOfColumns());

        final ConcurrentLinkedQueue<BruteRequest> tasks = new ConcurrentLinkedQueue<>();
        final ConcurrentLinkedQueue<BruteResult> results = new ConcurrentLinkedQueue<>();

        int activeThreads = 0;
        final Thread[] threads = new Thread[nThread];
        double itemsetsChecked = 0;

        for (int i = 0; i < nThread; ++i) {
            threads[i] = new Thread(() -> {
                while (true) {
                    final BruteRequest request = tasks.poll();

                    if (null == request) continue;

                    final ItemSet itemSet = request.getItemSet();

                    if (null == itemSet) {
                        results.add(new BruteResult(null, false));

                        break;
                    }

                    results.add(new BruteResult(itemSet,
                            VerificationUtils.isQuasiIdentifier(itemSet, dataset, k)
                    ));
                }
            });

            threads[i].start();
            ++activeThreads;

            if (generator.hasNext()) {
                tasks.add(new BruteRequest(generator.next()));
            }
        }

        boolean terminated = false;
        while(0 < activeThreads) {
            BruteResult result = results.poll();

            if (null == result) continue;

            ItemSet testedItemSet = result.getItemSet();

            if (null == testedItemSet) {
                --activeThreads;
                continue;
            }
            if (result.isUnique()) {
                generator.ban(testedItemSet);
            }

            if (generator.hasNext()) {
                ItemSet itemSet = generator.next();
                itemsetsChecked++;
                tasks.add(new BruteRequest(itemSet));
            } else if (! terminated) {
                for (int i = 0; i < nThread; ++i) {
                    tasks.add(new BruteRequest(null));
                }

                terminated = true;
            }
        }

        for (Thread t : threads) {
            try {
                t.join();
            } catch (InterruptedException ignored) {}
        }

        Collection<IPVVulnerability> vulnerabilities = new ArrayList<>();
        for(ItemSet itemSet: generator.getBanned()) {
            vulnerabilities.add(new IPVVulnerability(itemSet));
        }

        logger.info("Brute(parallel) itemsets checked: " + itemsetsChecked + " over the possible " + (Math.pow(2, dataset.getNumberOfColumns()) - 1));
        return vulnerabilities;

    }
}
