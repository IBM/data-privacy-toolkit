/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/
package com.ibm.research.drl.dpt.vulnerability.ducc;

import com.ibm.research.drl.dpt.IPVAlgorithm;
import com.ibm.research.drl.dpt.datasets.IPVDataset;
import com.ibm.research.drl.dpt.generators.ItemSet;
import com.ibm.research.drl.dpt.vulnerability.IPVVulnerability;
import com.ibm.research.drl.dpt.vulnerability.WithRowExtractor;

import java.util.*;
import java.util.concurrent.*;

public class DUCC implements IPVAlgorithm, WithRowExtractor {
    private final int nThread;
    private final Strategy strategy;
    private final int kValue;
    private PLIRepository pliRepository;

    /**
     * Instantiates a new Ducc.
     *
     * @param nThread  the n thread
     * @param strategy the strategy
     * @param kValue   the k value
     */
    public DUCC(final int nThread, final Strategy strategy, int kValue) {
        this.nThread = nThread;
        this.strategy = strategy;
        this.kValue = kValue;
    }

    @Override
    public Collection<IPVVulnerability> apply(IPVDataset dataset) {
        pliRepository = initializePLIRepositories(dataset);
        final PrunedGraphs graphs = new PrunedGraphs();
        final List<IPVVulnerability> vulnerabilities = new LinkedList<>();
        final DUCCPriorityBlockingQueue seeds = populateSeeds(pliRepository, graphs, vulnerabilities);

        // start workers
        final ExecutorService threadPool = Executors.newFixedThreadPool(nThread);
        final ExecutorCompletionService<Double> executor = new ExecutorCompletionService<>(threadPool);

        final List<Future<Double>> workers = new ArrayList<>(this.nThread);

        for (int i = 0; i < nThread; ++i) {
            workers.add(executor.submit(getWorkerFromStrategy(seeds, pliRepository, graphs, kValue)));
        }

        // collect results
        for (Future<Double> worker : workers) {
            try {
                Double value = worker.get();
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }

        threadPool.shutdown();

        return getUniqueVulnerabilites(vulnerabilities, graphs.getUniques());
    }

    private DUCCWorker getWorkerFromStrategy(DUCCPriorityBlockingQueue seeds, PLIRepository pliRepository, PrunedGraphs graphs, int kValue) {
        switch (strategy) {
            case DESCENDING:
                return new DUCCWorkerDescending(seeds, pliRepository, graphs, kValue);
            case RECURSIVE:
                return new DUCCWorkerRecursive(seeds, pliRepository, graphs, kValue);
            case WSYNC:
                return new DUCCWorkerRecursiveWithSync(seeds, pliRepository, graphs, kValue);
        }
        throw new IllegalArgumentException("Unknown strategy: " + strategy);
    }

    private Collection<IPVVulnerability> getUniqueVulnerabilites(final List<IPVVulnerability> vulnerabilities, List<ItemSet> itemSets) {
        for (final ItemSet itemSet : itemSets) {
            vulnerabilities.add(new IPVVulnerability(itemSet));
        }

        return vulnerabilities;
    }

    private PLIRepository initializePLIRepositories(IPVDataset dataset) {
        final PLIRepository repository = new PLIRepository();

        for (int attribute = 0; attribute < dataset.getNumberOfColumns(); ++attribute) {
            Map<String, RowIDSet> idxs = new TreeMap<>();

            for (int row = 0; row < dataset.getNumberOfRows(); ++row) {
                String value = dataset.get(row, attribute);

                if (!idxs.containsKey(value)) idxs.put(value, new RowIDSet());

                idxs.get(value).add(row);
            }

            repository.put(attribute, idxs.values());
        }

        return repository;
    }

    private DUCCPriorityBlockingQueue populateSeeds(PLIRepository pliRepository, PrunedGraphs graphs, List<IPVVulnerability> vulnerabilities) {
        final DUCCPriorityBlockingQueue seeds = new DUCCPriorityBlockingQueue();

        final List<Integer> itemSets = new ArrayList<>(pliRepository.keySet());

        for (int i = 0; i < itemSets.size(); ++i) {
            Integer is1 = itemSets.get(i);

            Collection<RowIDSet> uv1 = pliRepository.get(is1);
            if (null == uv1) continue;
            if (hasUnique(uv1)) {
                pliRepository.remove(is1);

                graphs.addUnique(new ItemSet(is1));
            } else {
                for (int j = i + 1; j < itemSets.size(); ++j) {
                    Integer is2 = itemSets.get(j);
                    Collection<RowIDSet> uv2 = pliRepository.get(is2);
                    if (null == uv2) continue;
                    if (hasUnique(uv2)) {
                        pliRepository.remove(is2);

                        graphs.addUnique(new ItemSet(is2));
                        continue;
                    }

                    seeds.add(new ItemSet(is1, is2));
                }
            }
        }

        return seeds;
    }

    private boolean hasUnique(Collection<RowIDSet> sets) {
        for (RowIDSet set : sets) {
            if (kValue > set.size())
                return true;
        }

        return false;
    }

    @Override
    public List<Integer> getRowIds(ItemSet itemSet) {
        final Set<Integer> rowIds = new TreeSet<>();

        Iterator<RowIDSet> allCombinations = DUCCWorkerDescending.getCombinations(pliRepository.getAll(itemSet));

        while (allCombinations.hasNext()) {
            final RowIDSet rowIDSet = allCombinations.next();

            if (rowIds.size() < kValue) {
                rowIds.addAll(rowIDSet);
            }
        }

        return new ArrayList<>(rowIds);
    }

    /**
     * The enum Strategy.
     */
    public enum Strategy {
        /**
         * Descending strategy.
         */
        DESCENDING,
        /**
         * Recursive strategy.
         */
        RECURSIVE,
        /**
         * Wsync strategy.
         */
        WSYNC
    }
}
