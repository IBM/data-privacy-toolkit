/*******************************************************************
 *                                                                 *
 * Copyright IBM Corp. 2022                                        *
 *                                                                 *
 *******************************************************************/
package com.ibm.research.drl.dpt.vulnerability.ducc;

import com.ibm.research.drl.dpt.IPVAlgorithm;
import com.ibm.research.drl.dpt.datasets.IPVDataset;
import com.ibm.research.drl.dpt.generators.ItemSet;
import com.ibm.research.drl.dpt.vulnerability.IPVVulnerability;
import com.ibm.research.drl.dpt.vulnerability.WithRowExtractor;

import java.util.*;
import java.util.concurrent.*;

public class DUCC implements IPVAlgorithm, WithRowExtractor {
    private final int nThread;
    private final Strategy strategy;
    private final int kValue;
    private PLIRepository pliRepository;

    /**
     * Instantiates a new Ducc.
     *
     * @param nThread  the n thread
     * @param strategy the strategy
     * @param kValue   the k value
     */
    public DUCC(final int nThread, final Strategy strategy, int kValue) {
        this.nThread = nThread;
        this.strategy = strategy;
        this.kValue = kValue;
    }

    @Override
    public Collection<IPVVulnerability> apply(IPVDataset dataset) {
        pliRepository = initializePLIRepositories(dataset);
        final PrunedGraphs graphs = new PrunedGraphs();
        final List<IPVVulnerability> vulnerabilities = new LinkedList<>();
        final DUCCPriorityBlockingQueue seeds = populateSeeds(pliRepository, graphs, vulnerabilities);

        // start workers
        final ExecutorService threadPool = Executors.newFixedThreadPool(nThread);
        final ExecutorCompletionService<Double> executor = new ExecutorCompletionService<>(threadPool);

        final List<Future<Double>> workers = new ArrayList<>(this.nThread);

        for (int i = 0; i < nThread; ++i) {
            workers.add(executor.submit(getWorkerFromStrategy(seeds, pliRepository, graphs, kValue)));
        }

        // collect results
        for (Future<Double> worker : workers) {
            try {
                Double value = worker.get();
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }

        threadPool.shutdown();

        return getUniqueVulnerabilites(vulnerabilities, graphs.getUniques());
    }

    private DUCCWorker getWorkerFromStrategy(DUCCPriorityBlockingQueue seeds, PLIRepository pliRepository, PrunedGraphs graphs, int kValue) {
        switch (strategy) {
            case DESCENDING:
                return new DUCCWorkerDescending(seeds, pliRepository, graphs, kValue);
            case RECURSIVE:
                return new DUCCWorkerRecursive(seeds, pliRepository, graphs, kValue);
            case WSYNC:
                return new DUCCWorkerRecursiveWithSync(seeds, pliRepository, graphs, kValue);
        }
        throw new IllegalArgumentException("Unknown strategy: " + strategy);
    }

    private Collection<IPVVulnerability> getUniqueVulnerabilites(final List<IPVVulnerability> vulnerabilities, List<ItemSet> itemSets) {
        for (final ItemSet itemSet : itemSets) {
            vulnerabilities.add(new IPVVulnerability(itemSet));
        }

        return vulnerabilities;
    }

    private PLIRepository initializePLIRepositories(IPVDataset dataset) {
        final PLIRepository repository = new PLIRepository();

        for (int attribute = 0; attribute < dataset.getNumberOfColumns(); ++attribute) {
            Map<String, RowIDSet> idxs = new TreeMap<>();

            for (int row = 0; row < dataset.getNumberOfRows(); ++row) {
                String value = dataset.get(row, attribute);

                if (!idxs.containsKey(value)) idxs.put(value, new RowIDSet());

                idxs.get(value).add(row);
            }

            repository.put(attribute, idxs.values());
        }

        return repository;
    }

    private DUCCPriorityBlockingQueue populateSeeds(PLIRepository pliRepository, PrunedGraphs graphs, List<IPVVulnerability> vulnerabilities) {
        final DUCCPriorityBlockingQueue seeds = new DUCCPriorityBlockingQueue();

        final List<Integer> itemSets = new ArrayList<>(pliRepository.keySet());

        for (int i = 0; i < itemSets.size(); ++i) {
            Integer is1 = itemSets.get(i);

            Collection<RowIDSet> uv1 = pliRepository.get(is1);
            if (null == uv1) continue;
            if (hasUnique(uv1)) {
                pliRepository.remove(is1);

                graphs.addUnique(new ItemSet(is1));
            } else {
                for (int j = i + 1; j < itemSets.size(); ++j) {
                    Integer is2 = itemSets.get(j);
                    Collection<RowIDSet> uv2 = pliRepository.get(is2);
                    if (null == uv2) continue;
                    if (hasUnique(uv2)) {
                        pliRepository.remove(is2);

                        graphs.addUnique(new ItemSet(is2));
                        continue;
                    }

                    seeds.add(new ItemSet(is1, is2));
                }
            }
        }

        return seeds;
    }

    private boolean hasUnique(Collection<RowIDSet> sets) {
        for (RowIDSet set : sets) {
            if (kValue > set.size())
                return true;
        }

        return false;
    }

    @Override
    public List<Integer> getRowIds(ItemSet itemSet) {
        final Set<Integer> rowIds = new TreeSet<>();

        Iterator<RowIDSet> allCombinations = DUCCWorkerDescending.getCombinations(pliRepository.getAll(itemSet));

        while (allCombinations.hasNext()) {
            final RowIDSet rowIDSet = allCombinations.next();

            if (rowIds.size() < kValue) {
                rowIds.addAll(rowIDSet);
            }
        }

        return new ArrayList<>(rowIds);
    }

    /**
     * The enum Strategy.
     */
    public enum Strategy {
        /**
         * Descending strategy.
         */
        DESCENDING, /**
         * Recursive strategy.
         */
        RECURSIVE, /**
         * Wsync strategy.
         */
        WSYNC
    }
}
