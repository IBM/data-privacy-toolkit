/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/
package com.ibm.research.drl.dpt.vulnerability.fpvi;

import com.ibm.research.drl.dpt.IPVAlgorithm;
import com.ibm.research.drl.dpt.datasets.IPVDataset;
import com.ibm.research.drl.dpt.generators.IPVGenerator;
import com.ibm.research.drl.dpt.generators.ItemSet;
import com.ibm.research.drl.dpt.generators.LayerGenerator;
import com.ibm.research.drl.dpt.vulnerability.IPVVulnerability;
import com.ibm.research.drl.dpt.vulnerability.WithRowExtractor;

import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;


public class FPVI implements IPVAlgorithm, WithRowExtractor {
    private final int nThread;
    private final int batchSize;
    private final double multiplier;
    private final int kValue;

    private FPVIIndex index;

    /**
     * Instantiates a new FPVI.
     *
     * @param nThread    the n thread
     * @param batchSize  the batch size
     * @param multiplier the multiplier
     * @param kValue     the k value
     */
    public FPVI(final int nThread, final int batchSize, final double multiplier, final int kValue) {
        this.nThread = nThread;
        this.batchSize = batchSize;
        this.multiplier = multiplier;
        this.kValue = kValue;
    }


    @Override
    public Collection<IPVVulnerability> apply(IPVDataset dataset) {
        final IPVGenerator generator = new LayerGenerator(dataset.getNumberOfColumns());

        index = new FPVIIndex().index(dataset, nThread);

        final FPVITaskGenerator taskGenerator = new FPVITaskGenerator(dataset.getNumberOfColumns(), dataset.getNumberOfRows(), batchSize, generator);

        final ConcurrentLinkedQueue<FPVITask> tasks = new ConcurrentLinkedQueue<>();
        final ConcurrentLinkedQueue<FPVIResult> results = new ConcurrentLinkedQueue<>();

        int parallelism = (int) (nThread * multiplier);
        for (int i = 0; generator.hasNext() && i < parallelism; ++i) {
            final FPVITask task = taskGenerator.next();

            tasks.add(task);
        }

        // init executors
        final Thread[] executors = new Thread[nThread];
        int counter = nThread;

        for (int i = 0; i < nThread; ++i) {
            executors[i] = new Thread(new Runnable() {
                private List<Set<Integer>> extractCandidates(int i, ItemSet itemSet) {
                    final List<Set<Integer>> candidates = new ArrayList<>(itemSet.size());

                    for (Integer j : itemSet.getItems()) {
                        candidates.add(index.getKeySet(i, j));
                    }

                    return candidates;
                }

                private boolean isUnique(List<Set<Integer>> candidates) {
                    if (1 == candidates.size()) {
                        return candidates.get(0).size() < kValue;
                    }

                    candidates.sort(Comparator.comparingInt(Set::size));

                    final Set<Integer> res = new HashSet<>(candidates.get(0));

                    if (res.size() < kValue) return true;

                    for (int i = 1; i < candidates.size(); ++i) {
                        final Set<Integer> next = candidates.get(i);

                        if (next.size() < kValue) return true;

                        res.removeIf(n -> !next.contains(n));

                        if (res.size() < kValue) return true;
                    }

                    return false;
                }

                @Override
                public void run() {
                    while (true) {
                        FPVITask task = tasks.poll();
                        FPVIResult result = null;

                        if (null == task) {
                            continue;
                        }

                        if (null == task.getItemSet() && -1 == task.getFrom() && -1 == task.getTo()) {
                            results.add(new FPVIResult(null, false));
                            return; // termination condition
                        }

                        for (int i = task.getFrom(); i < task.getTo(); ++i) {
                            final List<Set<Integer>> candidates = extractCandidates(i, task.getItemSet());

                            if (isUnique(candidates)) {
                                result = new FPVIResult(task, true);
                                break;
                            }
                        }

                        if (null == result) result = new FPVIResult(task, false);

                        results.add(result);
                    }
                }
            });

            executors[i].start();
        }

        boolean terminated = false;

        while (0 < counter) {
            FPVIResult result = results.poll();

            if (null == result) {
                continue;
            }

            FPVITask taskCompleted = result.getTask();

            if (null == taskCompleted) {
                --counter;
                continue;
            }

            if (result.isUnique()) {
                taskGenerator.ban(taskCompleted);
            }

            if (taskGenerator.hasNext()) {
                final FPVITask task = taskGenerator.next();
                tasks.add(task);
            } else if (!terminated) {
                for (int i = 0; i < nThread; ++i) {
                    tasks.add(new FPVITask(null, -1, -1));
                }

                terminated = true;
            }

        }

        for (Thread t : executors) {
            try {
                t.join();
            } catch (InterruptedException ignored) {
            }
        }

        final Collection<ItemSet> bannedItemSets = generator.getBanned();
        final List<IPVVulnerability> vulnerabilities = new ArrayList<>(bannedItemSets.size());

        for (final ItemSet banned : bannedItemSets)
            vulnerabilities.add(new IPVVulnerability(banned));

        return vulnerabilities;
    }

    @Override
    public List<Integer> getRowIds(ItemSet itemSet) {
        final List<Integer> rowIds = new LinkedList<>();

        for (int i = 0; i < index.numberOfRows(); ++i) {
            final Set<Integer> keySet = new HashSet<>();
            for (final Integer item : itemSet.getItems()) {
                if (keySet.isEmpty()) {
                    keySet.addAll(index.getKeySet(i, item));
                } else {
                    Set<Integer> newKeySet = index.getKeySet(i, item);

                    keySet.removeIf(element -> !newKeySet.contains(element));
                }

                if (keySet.size() < kValue) {
                    rowIds.add(i);
                    break;
                }
            }
        }

        return rowIds;
    }
}
