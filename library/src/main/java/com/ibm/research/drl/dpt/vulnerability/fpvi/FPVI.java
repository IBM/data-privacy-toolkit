/*******************************************************************
 *                                                                 *
 * Copyright IBM Corp. 2022                                        *
 *                                                                 *
 *******************************************************************/
package com.ibm.research.drl.dpt.vulnerability.fpvi;

import com.ibm.research.drl.dpt.IPVAlgorithm;
import com.ibm.research.drl.dpt.datasets.IPVDataset;
import com.ibm.research.drl.dpt.generators.IPVGenerator;
import com.ibm.research.drl.dpt.generators.ItemSet;
import com.ibm.research.drl.dpt.generators.LayerGenerator;
import com.ibm.research.drl.dpt.vulnerability.IPVVulnerability;
import com.ibm.research.drl.dpt.vulnerability.WithRowExtractor;

import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;


public class FPVI implements IPVAlgorithm, WithRowExtractor {
    private final int nThread;
    private final int batchSize;
    private final double multiplier;
    private final int kValue;

    private FPVIIndex index;

    /**
     * Instantiates a new FPVI.
     *
     * @param nThread    the n thread
     * @param batchSize  the batch size
     * @param multiplier the multiplier
     * @param kValue     the k value
     */
    public FPVI(final int nThread, final int batchSize, final double multiplier, final int kValue) {
        this.nThread = nThread;
        this.batchSize = batchSize;
        this.multiplier = multiplier;
        this.kValue = kValue;
    }


    @Override
    public Collection<IPVVulnerability> apply(IPVDataset dataset) {
        final IPVGenerator generator = new LayerGenerator(dataset.getNumberOfColumns());

        index = new FPVIIndex().index(dataset, nThread);

        final FPVITaskGenerator taskGenerator = new FPVITaskGenerator(dataset.getNumberOfColumns(), dataset.getNumberOfRows(), batchSize, generator);

        final ConcurrentLinkedQueue<FPVITask> tasks = new ConcurrentLinkedQueue<>();
        final ConcurrentLinkedQueue<FPVIResult> results = new ConcurrentLinkedQueue<>();

        int parallelism = (int) (nThread * multiplier);
        for (int i = 0; generator.hasNext() && i < parallelism; ++i) {
            final FPVITask task = taskGenerator.next();

            tasks.add(task);
        }

        // init executors
        final Thread[] executors = new Thread[nThread];
        int counter = nThread;

        for (int i = 0; i < nThread; ++i) {
            executors[i] = new Thread(new Runnable() {
                private List<Set<Integer>> extractCandidates(int i, ItemSet itemSet) {
                    final List<Set<Integer>> candidates = new ArrayList<>(itemSet.size());

                    for (Integer j : itemSet.getItems()) {
                        candidates.add(index.getKeySet(i, j));
                    }

                    return candidates;
                }

                private boolean isUnique(List<Set<Integer>> candidates) {
                    if (1 == candidates.size()) {
                        return candidates.get(0).size() < kValue;
                    }

                    candidates.sort(Comparator.comparingInt(Set::size));

                    final Set<Integer> res = new HashSet<>(candidates.get(0));

                    if (res.size() < kValue) return true;

                    for (int i = 1; i < candidates.size(); ++i) {
                        final Set<Integer> next = candidates.get(i);

                        if (next.size() < kValue) return true;

                        res.removeIf(n -> !next.contains(n));

                        if (res.size() < kValue) return true;
                    }

                    return false;
                }

                @Override
                public void run() {
                    while (true) {
                        FPVITask task = tasks.poll();
                        FPVIResult result = null;

                        if (null == task) {
                            continue;
                        }

                        if (null == task.getItemSet() && -1 == task.getFrom() && -1 == task.getTo()) {
                            results.add(new FPVIResult(null, false));
                            return; // termination condition
                        }

                        for (int i = task.getFrom(); i < task.getTo(); ++i) {
                            final List<Set<Integer>> candidates = extractCandidates(i, task.getItemSet());

                            if (isUnique(candidates)) {
                                result = new FPVIResult(task, true);
                                break;
                            }
                        }

                        if (null == result) result = new FPVIResult(task, false);

                        results.add(result);
                    }
                }
            });

            executors[i].start();
        }

        boolean terminated = false;

        while (0 < counter) {
            FPVIResult result = results.poll();

            if (null == result) {
                continue;
            }

            FPVITask taskCompleted = result.getTask();

            if (null == taskCompleted) {
                --counter;
                continue;
            }

            if (result.isUnique()) {
                taskGenerator.ban(taskCompleted);
            }

            if (taskGenerator.hasNext()) {
                final FPVITask task = taskGenerator.next();
                tasks.add(task);
            } else if (!terminated) {
                for (int i = 0; i < nThread; ++i) {
                    tasks.add(new FPVITask(null, -1, -1));
                }

                terminated = true;
            }

        }

        for (Thread t : executors) {
            try {
                t.join();
            } catch (InterruptedException ignored) {
            }
        }

        final Collection<ItemSet> bannedItemSets = generator.getBanned();
        final List<IPVVulnerability> vulnerabilities = new ArrayList<>(bannedItemSets.size());

        for (final ItemSet banned : bannedItemSets)
            vulnerabilities.add(new IPVVulnerability(banned));

        return vulnerabilities;
    }

    @Override
    public List<Integer> getRowIds(ItemSet itemSet) {
        final List<Integer> rowIds = new LinkedList<>();

        for (int i = 0; i < index.numberOfRows(); ++i) {
            final Set<Integer> keySet = new HashSet<>();
            for (final Integer item : itemSet.getItems()) {
                if (keySet.isEmpty()) {
                    keySet.addAll(index.getKeySet(i, item));
                } else {
                    Set<Integer> newKeySet = index.getKeySet(i, item);

                    keySet.removeIf(element -> !newKeySet.contains(element));
                }

                if (keySet.size() < kValue) {
                    rowIds.add(i);
                    break;
                }
            }
        }

        return rowIds;
    }
}
