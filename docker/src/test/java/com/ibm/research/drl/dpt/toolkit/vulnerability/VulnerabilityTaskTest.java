/*******************************************************************
 *                                                                 *
 * Copyright IBM Corp. 2022                                        *
 *                                                                 *
 *******************************************************************/
package com.ibm.research.drl.dpt.toolkit.vulnerability;

import com.fasterxml.jackson.core.type.TypeReference;
import com.ibm.research.drl.dpt.util.JsonUtils;
import com.ibm.research.drl.dpt.configuration.DataTypeFormat;
import com.ibm.research.drl.dpt.datasets.CSVDatasetOptions;
import org.junit.jupiter.api.Test;


import java.io.*;
import java.util.Arrays;
import java.util.Collections;
import java.util.Map;

import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.core.IsInstanceOf.instanceOf;

public class VulnerabilityTaskTest {
    @Test
    public void testFromFileShouldDeserializeCorrectly() throws IOException {
        final VulnerabilityTask taskToExecute;
        try (InputStream inputStream = VulnerabilityTaskTest.class.getResourceAsStream("/configuration_vulnerability.json")) {
            taskToExecute = JsonUtils.MAPPER.readValue(inputStream, VulnerabilityTask.class);
        }

        assertThat(taskToExecute.getInputFormat(), is(DataTypeFormat.CSV));

        assertThat(taskToExecute.getInputOptions(), instanceOf(CSVDatasetOptions.class));
        assertThat(((CSVDatasetOptions) taskToExecute.getInputOptions()).getFieldDelimiter(), is(','));
        assertThat(((CSVDatasetOptions) taskToExecute.getInputOptions()).getQuoteChar(), is('"'));
        assertThat(((CSVDatasetOptions) taskToExecute.getInputOptions()).isHasHeader(), is(true));
        assertThat(((CSVDatasetOptions) taskToExecute.getInputOptions()).isTrimFields(), is(false));

        assertThat(taskToExecute.getTaskOptions(), instanceOf(VulnerabilityOptions.class));
        assertThat(taskToExecute.getTaskOptions().getAlgorithm(), is(VulnerabilityOptions.Algorithm.BRUTE));
        assertThat(taskToExecute.getTaskOptions().isFullReport(), is(true));
        assertThat(taskToExecute.getTaskOptions().getK(), is(12));
        assertThat(taskToExecute.getTaskOptions().getnThreads(), is(1));
        assertThat(taskToExecute.getTaskOptions().getBatchSize(), is(1));
        assertThat(taskToExecute.getTaskOptions().getStrategy(), is(nullValue()));
    }

    @Test
    public void testExecuteShouldGenerateOutputCorrectly() throws IOException {
        final VulnerabilityTask vulnerabilityTask;
        try (InputStream inputStream = VulnerabilityTaskTest.class.getResourceAsStream("/configuration_vulnerability.json")) {
         vulnerabilityTask = JsonUtils.MAPPER.readValue(inputStream, VulnerabilityTask.class);
        }

        try (
                InputStream input = VulnerabilityTaskTest.class.getResourceAsStream("/input_vulnerability.csv");
                OutputStream output = new ByteArrayOutputStream();
        ) {
            vulnerabilityTask.processFile(input, output);

            Map<String, Object> report = JsonUtils.MAPPER.readValue(output.toString(), new TypeReference<>() {});

            assertThat(report.keySet().size(), is(4));
            assertThat(report.get("k"), is(12));
            assertThat(report.get("msg"), is("List of fields (zero-based) that violate the required k-uniqueness value"));
            assertThat(report.get("direct-identifiers"), is(Arrays.asList("1", "2", "3")));
            assertThat(report.get("quasi-identifiers"), is(Collections.emptyList()));
        }
    }
}