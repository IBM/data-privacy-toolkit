/*******************************************************************
 *                                                                 *
 * Copyright IBM Corp. 2022                                        *
 *                                                                 *
 *******************************************************************/
package com.ibm.research.drl.dpt.toolkit.vulnerability;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.ibm.research.drl.dpt.IPVAlgorithm;
import com.ibm.research.drl.dpt.configuration.DataTypeFormat;
import com.ibm.research.drl.dpt.datasets.CSVDatasetOptions;
import com.ibm.research.drl.dpt.datasets.DatasetOptions;
import com.ibm.research.drl.dpt.datasets.JSONDatasetOptions;
import com.ibm.research.drl.dpt.exceptions.MisconfigurationException;
import com.ibm.research.drl.dpt.processors.FormatProcessor;
import com.ibm.research.drl.dpt.processors.FormatProcessorFactory;
import com.ibm.research.drl.dpt.toolkit.dataset.GenericDatasetOptions;
import com.ibm.research.drl.dpt.toolkit.task.TaskToExecute;
import com.ibm.research.drl.dpt.vulnerability.IPVVulnerability;
import com.ibm.research.drl.dpt.vulnerability.brute.ParallelBrute;
import com.ibm.research.drl.dpt.vulnerability.ducc.DUCC;
import com.ibm.research.drl.dpt.vulnerability.fpvi.FPVI;
import com.ibm.research.drl.dpt.vulnerability.mtra.MTRA;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;


import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class VulnerabilityTask extends TaskToExecute {
    private static final Logger logger = LogManager.getLogger(VulnerabilityTask.class);

    private final VulnerabilityOptions vulnerabilityOptions;
    private final ObjectMapper mapper;

    @JsonCreator
    public VulnerabilityTask(
            @JsonProperty("task") String task,
            @JsonProperty("extension") String extension,
            @JsonProperty("inputFormat") DataTypeFormat inputFormat,
            @JsonTypeInfo(
                    use = JsonTypeInfo.Id.NAME,
                    include = JsonTypeInfo.As.EXTERNAL_PROPERTY,
                    property = "inputFormat",
                    defaultImpl = GenericDatasetOptions.class
            )
            @JsonSubTypes({
                    @JsonSubTypes.Type(value = CSVDatasetOptions.class, name = "CSV"),
                    @JsonSubTypes.Type(value = JSONDatasetOptions.class, name = "JSON")
            })
            @JsonProperty("inputOptions") DatasetOptions inputOptions,
            @JsonProperty("taskOptions") VulnerabilityOptions vulnerabilityOptions,
            @JsonProperty("outputFormat") DataTypeFormat outputFormat,
            @JsonTypeInfo(
                    use = JsonTypeInfo.Id.NAME,
                    include = JsonTypeInfo.As.EXTERNAL_PROPERTY,
                    property = "outputFormat",
                    defaultImpl = GenericDatasetOptions.class
            )
            @JsonSubTypes({
                    @JsonSubTypes.Type(value = CSVDatasetOptions.class, name = "CSV"),
                    @JsonSubTypes.Type(value = JSONDatasetOptions.class, name = "JSON")
            })
            @JsonProperty("outputOptions") DatasetOptions outputOptions
     ) {
        super(task, extension, inputFormat, inputOptions, outputFormat, outputOptions);
        this.vulnerabilityOptions = vulnerabilityOptions;
        mapper = new ObjectMapper();
    }

    @Override
    public void processFile(InputStream input, OutputStream output) throws IOException, MisconfigurationException {
        final IPVAlgorithm ipvAlgorithm = generateAlgorithm();

        FormatProcessor formatProcessor = FormatProcessorFactory.getProcessor(this.getInputFormat());

        Map<IPVVulnerability, List<Integer>> vulnerabilities = formatProcessor.identifyVulnerabilitiesStream(
                input,
                ipvAlgorithm,
                this.getInputFormat(),
                this.getInputOptions(),
                this.getTaskOptions().isFullReport(),
                this.getTaskOptions().getK()
        );

        writerReport(output, vulnerabilities);
    }

    @Override
    public VulnerabilityOptions getTaskOptions() {
        return this.vulnerabilityOptions;
    }

    @Override
    public String buildOutputExtension() {
        return "json";
    }

    private IPVAlgorithm generateAlgorithm() {

        switch (getTaskOptions().getAlgorithm()) {
            case FPVI:
                return new FPVI(getTaskOptions().getnThreads(), getTaskOptions().getBatchSize(), 1.5, getTaskOptions().getK());

            case DUCC:
                return new DUCC(getTaskOptions().getnThreads(), getTaskOptions().getStrategy(), getTaskOptions().getK());

            case MTRA:
                return new MTRA(getTaskOptions().getnThreads(), 1.5);

            case BRUTE:
            default:
                return new ParallelBrute(getTaskOptions().getK(), getTaskOptions().getnThreads());
        }
    }

    private void writerReport(OutputStream output, Map<IPVVulnerability, List<Integer>> vulnerabilities) throws IOException {
        Map<String, Object> report = new HashMap<>();
        report.put("msg", "List of fields (zero-based) that violate the required k-uniqueness value");
        report.put("k", getTaskOptions().getK());
        report.put("direct-identifiers", getDirectIdentifiers(vulnerabilities));
        report.put("quasi-identifiers", getQuasiIdentifiers(vulnerabilities));

        mapper.writer().writeValue(output, report);
    }

    private List<String> getQuasiIdentifiers(Map<IPVVulnerability, List<Integer>> vulnerabilities) {
        return vulnerabilities.keySet().stream()
                .map(vulnerability -> vulnerability.getItemSet().getItems())
                .filter( items -> items.size() != 1)
                .flatMap(Collection::stream)
                .map(Object::toString)
                .distinct()
                .sorted()
                .collect(Collectors.toList());
    }

    private List<String> getDirectIdentifiers(Map<IPVVulnerability, List<Integer>> vulnerabilities) {
        return vulnerabilities.keySet().stream()
                .map(vulnerability -> vulnerability.getItemSet().getItems())
                .filter( items -> items.size() == 1)
                .flatMap(Collection::stream)
                .map(Object::toString)
                .distinct()
                .sorted()
                .collect(Collectors.toList());
    }
}
