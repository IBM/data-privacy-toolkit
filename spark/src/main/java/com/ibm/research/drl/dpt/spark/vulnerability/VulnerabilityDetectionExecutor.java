/*******************************************************************
 *                                                                 *
 * Copyright IBM Corp. 2019                                        *
 *                                                                 *
 *******************************************************************/
package com.ibm.research.drl.dpt.spark.vulnerability;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.ibm.research.drl.dpt.spark.DPTSparkDriver;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.ParseException;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.apache.spark.SparkConf;
import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;
import org.apache.spark.sql.SparkSession;
import scala.collection.JavaConverters;

import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class VulnerabilityDetectionExecutor extends DPTSparkDriver {
    private static final Logger logger = LogManager.getLogger(VulnerabilityDetectionExecutor.class);

    private VulnerabilityDetectionOptions vulnerabilityDetectionOptions;

//    @Override
//    protected void init(String[] args) throws IOException, ParseException {
//        super.init(args);
//
//        this.vulnerabilityDetectionOptions = VulnerabilityDetectionOptions.fromJson(confJson);
//    }

//    @Override
//    public void run(SparkSession sparkSession) throws IOException {
//        Dataset<Row> inputDataset = inputRef.readDataset(sparkSession);
//
//        if (this.vulnerabilityDetectionOptions.getExcludedFields() != null && !this.vulnerabilityDetectionOptions.getExcludedFields().isEmpty()) {
//            inputDataset = doDropping(inputDataset, this.vulnerabilityDetectionOptions.getExcludedFields());
//        }
//
//        final VulnerabilityReport report = identifyVulnerabilities(
//                inputDataset,
//                this.vulnerabilityDetectionOptions.getStrategy(),
//                this.vulnerabilityDetectionOptions.getK(),
//                this.vulnerabilityDetectionOptions.getMaxSize(),
//                this.vulnerabilityDetectionOptions.isReport()
//        );
//
//        new ObjectMapper().writeValue(
//                this.outputRef.asOutputStream(),
//                report
//        );
//    }

//    public static void main(String[] args) throws IOException {
//        VulnerabilityDetectionExecutor executor = new VulnerabilityDetectionExecutor();
//
//        try {
//            executor.init(args);
//        } catch (ParseException e) {
//            String header = "Vulnerability detection\n\n";
//            String footer = "\n";
//            HelpFormatter formatter = new HelpFormatter();
//            formatter.printHelp("VulnerabilityDetection", header, executor.options, footer, true);
//            throw new RuntimeException("invalid arguments");
//        }
//
//        SparkSession session = SparkSession.builder().config(new SparkConf(true).setAppName("Vulnerability detection")).getOrCreate();
//
//        executor.run(session);
//
//        session.stop();
//    }

    private static Dataset<Row> doDropping(Dataset<Row> originalDataset, Set<String> excludedFields) {
        logger.info("Excluded fields: " + excludedFields);
        return originalDataset.drop(JavaConverters.asScalaSetConverter(excludedFields).asScala().toSeq());
    }

    static VulnerabilityReport identifyVulnerabilities(Dataset<Row> dataset, VulnerabilityDetectionStrategy strategy, int k, int maxSize, boolean withFullReport) {

        final VulnerabilityDetection vulnerabilityDetection;
        switch (strategy) {
            case BruteForce:
                logger.info("Executing search with pruning (BruteForce)");
                vulnerabilityDetection = new VulnerabilityDetectionWithBruteForce();
                break;
            case DUCC:
                logger.info("Executing search with pruning (DUCC)");
                vulnerabilityDetection = new VulnerabilityDetectionWithDUCC();
                break;
            case MTRA:
                logger.info("Executing search with pruning (MTRA)");
                vulnerabilityDetection = new VulnerabilityDetectionWithMTRA();
                break;
            case BruteForceWithoutPruning:
            default:
                logger.info("Executing default search without pruning (BruteForce)");
                vulnerabilityDetection = new VulnerabilityDetectionWithBruteForceWithoutPruning();
                break;
        }

        long totalRecords = dataset.count();

        final Collection<List<String>> vulnerabilities = vulnerabilityDetection.findVulnerabilities(dataset, k, maxSize);

        final Map<List<String>, Long> offendingRecords;
        if (withFullReport) {
            offendingRecords =  vulnerabilityDetection.computeOffendingRecords(dataset, vulnerabilities, k);
        } else {
            offendingRecords = null;
        }

        return new VulnerabilityReport(k, vulnerabilities, offendingRecords, totalRecords);
    }
}
