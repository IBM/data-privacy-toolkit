/*******************************************************************
 *                                                                 *
 * Copyright IBM Corp. 2019                                        *
 *                                                                 *
 *******************************************************************/
package com.ibm.research.drl.dpt.spark.vulnerability;

import com.ibm.research.drl.dpt.generators.IPVGenerator;
import com.ibm.research.drl.dpt.generators.ItemSet;
import com.ibm.research.drl.dpt.generators.LayerGenerator;
import com.ibm.research.drl.dpt.vulnerability.IPVVulnerability;
import org.apache.commons.lang3.NotImplementedException;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.function.Function;
import org.apache.spark.api.java.function.Function2;
import org.apache.spark.api.java.function.PairFunction;
import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import scala.Tuple2;

import java.util.*;

public class VulnerabilityDetectionWithMTRA extends VulnerabilityDetection {
    private static final Logger log = LoggerFactory.getLogger(VulnerabilityDetectionWithMTRA.class);

    @Override
    public Collection<List<String>> findVulnerabilities(final Dataset<Row> dataset, final int k, int maxSize) {
        throw new NotImplementedException();
    }

    @Override
    protected Map<List<String>, Long> computeOffendingRecords(Dataset<Row> dataset, Collection<List<String>> vulnerabilities, int k) {
        throw new NotImplementedException();
    }

    public static Collection<IPVVulnerability> run(JavaRDD<String> rdd, boolean hasHeader, final String separator) {
        final List<IPVVulnerability> vulnerabilities = new ArrayList<>();

        if (hasHeader) {
            rdd = rdd.zipWithIndex().filter((Function<Tuple2<String, Long>, Boolean>) rows -> rows._2() > 0).keys();
        }

        final JavaRDD<String[]> rddOfParts = rdd.map((Function<String, String[]>) entry -> entry.split(separator)).cache();

        final int nColumns = rddOfParts.first().length;

        final IPVGenerator generator = new LayerGenerator(nColumns);

        while(generator.hasNext()) {
            final ItemSet itemSet = generator.next();
            final Collection<Integer> items = itemSet.getItems();
            
            final int k = rddOfParts.mapToPair((PairFunction<String[], String, Integer>) strings -> {
                StringBuilder builder = new StringBuilder();

                for (Integer item : items) {
                    if (builder.length() != 0) {
                        builder.append(',');
                    }
                    builder.append(strings[item]);
                }

                return new Tuple2<>(builder.toString(), 1);
            }).reduceByKey((Function2<Integer, Integer, Integer>) Integer::sum)
                    .map((Function<Tuple2<String, Integer>, Integer>) Tuple2::_2)
                    .min(Comparator.comparingInt(o -> o));
            
            vulnerabilities.add(new IPVVulnerability(itemSet, k));
        }

        return vulnerabilities;
    }
}
