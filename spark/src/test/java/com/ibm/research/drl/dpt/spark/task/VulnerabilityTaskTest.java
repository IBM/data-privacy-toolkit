/*******************************************************************
 *                                                                 *
 * Copyright IBM Corp. 2023                                        *
 *                                                                 *
 *******************************************************************/
package com.ibm.research.drl.dpt.spark.task;

import com.ibm.research.drl.dpt.configuration.DataTypeFormat;
import com.ibm.research.drl.dpt.datasets.CSVDatasetOptions;
import com.ibm.research.drl.dpt.spark.dataset.reference.FileDatasetReference;
import com.ibm.research.drl.dpt.spark.dataset.reference.InMemoryDatasetReference;
import com.ibm.research.drl.dpt.spark.task.option.VulnerabilityTaskOptions;
import org.apache.spark.SparkConf;
import org.apache.spark.SparkContext;
import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;
import org.apache.spark.sql.SparkSession;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.*;

import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.jupiter.api.Assertions.assertNotNull;

class VulnerabilityTaskTest {
    private SparkSession sparkSession;

    @BeforeEach
    public void setUp() {
        SparkConf sparkConf =
                (new SparkConf())
                        .setMaster("local[1]")
                        .setAppName("test")
                        .set("spark.ui.enabled", "false")
                        .set("spark.app.id", UUID.randomUUID().toString())
                        .set("spark.driver.host", "localhost")
                        .set("spark.sql.shuffle.partitions", "1");

        this.sparkSession = SparkSession.builder().sparkContext(new SparkContext(sparkConf)).getOrCreate();
    }

    @AfterEach
    public void tearDown() {
        if (this.sparkSession != null) {
            this.sparkSession.stop();
        }
    }

    @Test
    public void testHighKReturnsOnlyDirect() {
        final VulnerabilityTask vulnerabilityTask = new VulnerabilityTask(
                "Vulnerability",
                new FileDatasetReference("", DataTypeFormat.CSV, new CSVDatasetOptions(true, ',', '\\', false),
                        "", false),
                new InMemoryDatasetReference(), new VulnerabilityTaskOptions(VulnerabilityTaskOptions.Algorithm.BRUTE, false, 12, 1, 1, null)
        );

        Dataset<Row> output = vulnerabilityTask.process(vulnerabilityTask.readInputDataset(
                Objects.requireNonNull(VulnerabilityTaskTest.class.getResource("/input_vulnerability.csv")).getFile()));

        assertNotNull(output);

        Map<String, Object> report = vulnerabilityTask.reportToMap(output);

        assertThat(report.get("k"), is(12));
        assertThat(report.get("direct-identifiers"), is(Arrays.asList("id2", "answer", "gender")));
        assertThat(report.get("quasi-identifiers"), is(Collections.emptyList()));
    }

    @Test
    public void testLowK() {
        final VulnerabilityTask vulnerabilityTask = new VulnerabilityTask(
                "Vulnerability",
                new FileDatasetReference("", DataTypeFormat.CSV, new CSVDatasetOptions(true, ',', '\\', false),
                        "", false),
                new InMemoryDatasetReference(), new VulnerabilityTaskOptions(VulnerabilityTaskOptions.Algorithm.BRUTE, false, 5, 1, 1, null)
        );

        Dataset<Row> output = vulnerabilityTask.process(vulnerabilityTask.readInputDataset(
                Objects.requireNonNull(VulnerabilityTaskTest.class.getResource("/input_vulnerability.csv")).getFile()));

        assertNotNull(output);

        Map<String, Object> report = vulnerabilityTask.reportToMap(output);

        assertThat(report.get("k"), is(5));
        assertThat(report.get("direct-identifiers"), is(Arrays.asList("id2", "answer", "gender")));
        assertThat(report.get("quasi-identifiers"), is(Collections.emptyList()));
    }
}