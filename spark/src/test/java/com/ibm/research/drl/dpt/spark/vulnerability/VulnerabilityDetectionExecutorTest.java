/*******************************************************************
 *                                                                 *
 * Copyright IBM Corp. 2018                                        *
 *                                                                 *
 *******************************************************************/
package com.ibm.research.drl.dpt.spark.vulnerability;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.apache.spark.SparkConf;
import org.apache.spark.SparkContext;
import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;
import org.apache.spark.sql.SparkSession;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.*;

import static org.hamcrest.CoreMatchers.*;
import static org.hamcrest.MatcherAssert.assertThat;

public class VulnerabilityDetectionExecutorTest {
    private SparkSession spark;
    private Dataset<Row> adultDataset;

    @BeforeEach
    public void setUp() {
        SparkConf sparkConf =
                (new SparkConf())
                        .setMaster("local[1]")
                        .setAppName("test")
                        .set("spark.ui.enabled", "false")
                        .set("spark.app.id", UUID.randomUUID().toString())
                        .set("spark.driver.host", "localhost")
                        .set("spark.sql.shuffle.partitions", "1");

        spark = SparkSession.builder().sparkContext(new SparkContext(sparkConf)).getOrCreate();
        adultDataset = spark.read().csv(VulnerabilityDetectionExecutorTest.class.getResource("/adult-10-30000.data.csv").getPath());
    }

    @AfterEach
    public void tearDown() {
        if (Objects.nonNull(spark)) {
            spark.stop();
        }
    }

    @Test
    public void identifyVulnerabilitiesWithBruteShouldDetectVulnerabilitiesCorrectly() {

        final Dataset<Row> dataset = adultDataset.select("_c0", "_c1", "_c2"); // too much time and too many vulns returned if we don't select down to 3 columns only
        final int k = 3;
        final int maxSize = 0;
        final boolean withFullReport = true;

        final VulnerabilityReport vulnerabilityReport = VulnerabilityDetectionExecutor.identifyVulnerabilities(
                dataset,
                VulnerabilityDetectionStrategy.BruteForceWithoutPruning,
                k,
                maxSize,
                withFullReport
        );

        assertThat(vulnerabilityReport, is(not(nullValue())));

        assertThat(vulnerabilityReport.getTotalRecords(), is(dataset.count()));

        assertThat(vulnerabilityReport.getK(), is(k));

        final Collection<List<String>> vulnerabilities = vulnerabilityReport.getVulnerabilities();
        final List<List<String>> expectedVulnerabilities = new ArrayList<>();
        expectedVulnerabilities.add(Arrays.asList("_c0"));
        expectedVulnerabilities.add(Arrays.asList("_c2"));
        expectedVulnerabilities.add(Arrays.asList("_c0", "_c1"));
        expectedVulnerabilities.add(Arrays.asList("_c0", "_c2"));
        expectedVulnerabilities.add(Arrays.asList("_c1", "_c2"));
        expectedVulnerabilities.add(Arrays.asList("_c0", "_c1", "_c2"));
        assertThat(vulnerabilities, is(expectedVulnerabilities));

        final Map<List<String>, Long> offendingRecords = vulnerabilityReport.getOffendingRecords();
        Map<List<String>, Long> expectedOffendingRecords = new HashMap<>();
        expectedOffendingRecords.put(Arrays.asList("_c0", "_c1", "_c2"), 29519L);
        expectedOffendingRecords.put(Arrays.asList("_c0"), 3L);
        expectedOffendingRecords.put(Arrays.asList("_c1", "_c2"), 25686L);
        expectedOffendingRecords.put(Arrays.asList("_c2"), 21934L);
        expectedOffendingRecords.put(Arrays.asList("_c0", "_c1"), 73L);
        expectedOffendingRecords.put(Arrays.asList("_c0", "_c2"), 28883L);
        assertThat(offendingRecords, is(expectedOffendingRecords));
    }

    @Test
    public void identifyVulnerabilitiesWithBruteForceWithoutPruningShouldDetectVulnerabilitiesCorrectly() throws JsonProcessingException {
        final Dataset<Row> dataset = adultDataset.select("_c0", "_c1", "_c2"); // too much time and too many vulns returned if we don't select down to 3 columns only
        final int k = 3;
        final int maxSize = 0;
        final boolean withFullReport = true;

        final VulnerabilityReport vulnerabilityReport = VulnerabilityDetectionExecutor.identifyVulnerabilities(
                dataset,
                VulnerabilityDetectionStrategy.BruteForce,
                k,
                maxSize,
                withFullReport
        );

        assertThat(vulnerabilityReport, is(not(nullValue())));

        assertThat(vulnerabilityReport.getTotalRecords(), is(dataset.count()));

        assertThat(vulnerabilityReport.getK(), is(k));

        final Collection<List<String>> vulnerabilities = vulnerabilityReport.getVulnerabilities();

        final List<List<String>> expectedVulnerabilities = new ArrayList<>();
        expectedVulnerabilities.add(Arrays.asList("_c0"));
        expectedVulnerabilities.add(Arrays.asList("_c2"));
        assertThat(vulnerabilities, is(expectedVulnerabilities));

        final Map<List<String>, Long> offendingRecords = vulnerabilityReport.getOffendingRecords();

        Map<List<String>, Long> expectedOffendingRecords = new HashMap<>();
        expectedOffendingRecords.put(Arrays.asList("_c0"), 3L);
        expectedOffendingRecords.put(Arrays.asList("_c2"), 21934L);
        assertThat(offendingRecords, is(expectedOffendingRecords));
    }

    @Test
    public void identifyVulnerabilitiesWithDUCCShouldDetectVulnerabilitiesCorrectly() {
        final Dataset<Row> dataset = adultDataset.select("_c0", "_c1", "_c2"); // too much time and too many vulns returned if we don't select down to 3 columns only
        final int k = 3;
        final int maxSize = 0;
        final boolean withFullReport = true;

        final VulnerabilityReport vulnerabilityReport = VulnerabilityDetectionExecutor.identifyVulnerabilities(
                dataset,
                VulnerabilityDetectionStrategy.DUCC,
                k,
                maxSize,
                withFullReport
        );

        assertThat(vulnerabilityReport, is(not(nullValue())));

        assertThat(vulnerabilityReport.getTotalRecords(), is(dataset.count()));

        assertThat(vulnerabilityReport.getK(), is(k));

        final Collection<List<String>> vulnerabilities = vulnerabilityReport.getVulnerabilities();

        final List<List<String>> expectedVulnerabilities = new ArrayList<>();
        expectedVulnerabilities.add(Arrays.asList("_c0"));
        expectedVulnerabilities.add(Arrays.asList("_c2"));
        assertThat(vulnerabilities, is(expectedVulnerabilities));

        final Map<List<String>, Long> offendingRecords = vulnerabilityReport.getOffendingRecords();

        Map<List<String>, Long> expectedOffendingRecords = new HashMap<>();
        expectedOffendingRecords.put(Arrays.asList("_c0"), 3L);
        expectedOffendingRecords.put(Arrays.asList("_c2"), 21934L);
        assertThat(offendingRecords, is(expectedOffendingRecords));
    }
}